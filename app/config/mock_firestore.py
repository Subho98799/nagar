"""
Lightweight JSON-backed mock Firestore for local development.

Provides a minimal subset of Firestore client API used by the app:
- collection(name).document(id=None).set(dict)
- document.update(dict)
- document.get() -> snapshot (has .to_dict(), .id, .exists)
- collection.where(field, op, value).stream()
- collection.order_by(field, direction=...).stream()
- collection.document() with autogenerated id
- collection.stream()
- db.collections()

This mock persists data to a JSON file so state is retained across restarts.
"""

from typing import Any, Dict, List, Optional
import json
import os
import uuid
from copy import deepcopy
from datetime import datetime
import threading
import logging

from firebase_admin import firestore as real_firestore

logger = logging.getLogger(__name__)


class MockDocumentSnapshot:
    def __init__(self, doc_id: str, data: Dict[str, Any]):
        self.id = doc_id
        self._data = deepcopy(data)

    @property
    def exists(self) -> bool:
        return self._data is not None

    def to_dict(self) -> Dict[str, Any]:
        return deepcopy(self._data)


class MockDocumentRef:
    def __init__(self, db: 'MockFirestore', collection: str, doc_id: str):
        self._db = db
        self._collection = collection
        self.id = doc_id

    def set(self, data: Dict[str, Any]) -> None:
        # Replace sentinel server timestamps with current UTC
        data = deepcopy(data)
        for k, v in data.items():
            if v is real_firestore.SERVER_TIMESTAMP:
                data[k] = datetime.utcnow().isoformat()

        self._db._set_doc(self._collection, self.id, data)

    def update(self, update_data: Dict[str, Any]) -> None:
        data = deepcopy(update_data)
        for k, v in data.items():
            if v is real_firestore.SERVER_TIMESTAMP:
                data[k] = datetime.utcnow().isoformat()

        self._db._update_doc(self._collection, self.id, data)

    def get(self) -> MockDocumentSnapshot:
        data = self._db._get_doc(self._collection, self.id)
        return MockDocumentSnapshot(self.id, data)


class MockQuery:
    def __init__(self, db: 'MockFirestore', collection: str, filters: List[tuple] = None):
        self._db = db
        self._collection = collection
        self._filters = filters or []
        self._order = None
        self._limit = None

    def where(self, field: str, op: str, value: Any) -> 'MockQuery':
        new_filters = list(self._filters)
        new_filters.append((field, op, value))
        return MockQuery(self._db, self._collection, new_filters)

    def order_by(self, field: str, direction: Any = None) -> 'MockQuery':
        q = MockQuery(self._db, self._collection, list(self._filters))
        q._order = (field, direction)
        return q

    def limit(self, n: int) -> 'MockQuery':
        q = MockQuery(self._db, self._collection, list(self._filters))
        q._order = self._order
        q._limit = n
        return q

    def stream(self):
        docs = self._db._list_docs(self._collection)

        # Apply filters
        def matches(doc):
            for field, op, value in self._filters:
                doc_value = doc.get(field)
                if op == "==":
                    if doc_value != value:
                        return False
                elif op == ">=":
                    if doc_value is None:
                        return False
                    # Assume ISO timestamps for created_at
                    try:
                        # If value is datetime, compare; if string, compare lexicographically
                        if isinstance(value, datetime):
                            v1 = datetime.fromisoformat(doc_value) if isinstance(doc_value, str) else doc_value
                            if v1 < value:
                                return False
                        else:
                            if doc_value < value:
                                return False
                    except Exception:
                        return False
                else:
                    # Unsupported operator -> skip this filter
                    return False
            return True

        matched = [MockDocumentSnapshot(doc_id, data) for doc_id, data in docs.items() if matches(data)]

        # Order
        if self._order:
            field, direction = self._order
            reverse = False
            try:
                from firebase_admin import firestore as ff
                if direction == ff.Query.DESCENDING:
                    reverse = True
            except Exception:
                pass

            def key_fn(snap: MockDocumentSnapshot):
                v = snap.to_dict().get(field)
                # Try ISO datetime
                try:
                    return datetime.fromisoformat(v) if isinstance(v, str) else v
                except Exception:
                    return v

            matched.sort(key=key_fn, reverse=reverse)

        # Limit
        if self._limit is not None:
            matched = matched[: self._limit]

        for snap in matched:
            yield snap


class MockCollection:
    def __init__(self, db: 'MockFirestore', name: str):
        self._db = db
        self._name = name

    def document(self, doc_id: Optional[str] = None) -> MockDocumentRef:
        if doc_id is None:
            doc_id = uuid.uuid4().hex
        return MockDocumentRef(self._db, self._name, doc_id)

    def stream(self):
        docs = self._db._list_docs(self._name)
        for doc_id, data in docs.items():
            yield MockDocumentSnapshot(doc_id, data)

    def where(self, field: str, op: str, value: Any) -> MockQuery:
        return MockQuery(self._db, self._name, [(field, op, value)])

    def order_by(self, field: str, direction: Any = None) -> MockQuery:
        return MockQuery(self._db, self._name, []).order_by(field, direction)


class MockFirestore:
    def __init__(self, path: str = "./mock_db.json"):
        self._path = path
        self._lock = threading.Lock()
        self._data: Dict[str, Dict[str, Any]] = {}
        self._load()

    def _load(self):
        if os.path.exists(self._path):
            try:
                with open(self._path, "r", encoding="utf-8") as f:
                    raw = json.load(f)
                    # Ensure keys map properly
                    self._data = raw
            except Exception as e:
                logger.warning(f"Failed to load mock DB file {self._path}: {e}")
                self._data = {}
        else:
            self._data = {}

    def _save(self):
        try:
            tmp = self._path + ".tmp"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(self._data, f, default=str, indent=2)
            os.replace(tmp, self._path)
        except Exception as e:
            logger.error(f"Failed to save mock DB to {self._path}: {e}")

    def _ensure_collection(self, name: str):
        if name not in self._data:
            self._data[name] = {}

    def _set_doc(self, collection: str, doc_id: str, data: Dict[str, Any]):
        with self._lock:
            self._ensure_collection(collection)
            # Convert datetimes to ISO strings
            for k, v in list(data.items()):
                if isinstance(v, datetime):
                    data[k] = v.isoformat()
            self._data[collection][doc_id] = data
            self._save()

    def _update_doc(self, collection: str, doc_id: str, update_data: Dict[str, Any]):
        with self._lock:
            self._ensure_collection(collection)
            existing = self._data[collection].get(doc_id, {})
            for k, v in update_data.items():
                existing[k] = v
            self._data[collection][doc_id] = existing
            self._save()

    def _get_doc(self, collection: str, doc_id: str) -> Optional[Dict[str, Any]]:
        with self._lock:
            self._ensure_collection(collection)
            return deepcopy(self._data[collection].get(doc_id))

    def _list_docs(self, collection: str) -> Dict[str, Dict[str, Any]]:
        with self._lock:
            self._ensure_collection(collection)
            return deepcopy(self._data[collection])

    # Public API
    def collection(self, name: str) -> MockCollection:
        return MockCollection(self, name)

    def collections(self) -> List[MockCollection]:
        return [MockCollection(self, name) for name in list(self._data.keys())]


_mock_db_instance: Optional[MockFirestore] = None


def get_mock_db(path: str = "./mock_db.json") -> MockFirestore:
    global _mock_db_instance
    if _mock_db_instance is None:
        _mock_db_instance = MockFirestore(path)
    return _mock_db_instance
